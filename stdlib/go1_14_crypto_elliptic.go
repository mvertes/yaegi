// Code generated by 'goexports crypto/elliptic'. DO NOT EDIT.

// +build go1.14,!go1.15

package stdlib

import (
	"crypto/elliptic"
	"math/big"
	"reflect"

	"github.com/containous/yaegi/interp"
)

func init() {
	Symbols["crypto/elliptic"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"GenerateKey": reflect.ValueOf(elliptic.GenerateKey),
		"Marshal":     reflect.ValueOf(elliptic.Marshal),
		"P224":        reflect.ValueOf(elliptic.P224),
		"P256":        reflect.ValueOf(elliptic.P256),
		"P384":        reflect.ValueOf(elliptic.P384),
		"P521":        reflect.ValueOf(elliptic.P521),
		"Unmarshal":   reflect.ValueOf(elliptic.Unmarshal),

		// type definitions
		"Curve":       reflect.ValueOf((*elliptic.Curve)(nil)),
		"CurveParams": reflect.ValueOf((*elliptic.CurveParams)(nil)),
	}
}
func (_w Wrapper) Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (x *big.Int, y *big.Int) {
	_f := interp.Method("Add", _w.Wrap).(func(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (x *big.Int, y *big.Int))
	return _f(x1, y1, x2, y2)
}
func (_w Wrapper) Double(x1 *big.Int, y1 *big.Int) (x *big.Int, y *big.Int) {
	_f := interp.Method("Double", _w.Wrap).(func(x1 *big.Int, y1 *big.Int) (x *big.Int, y *big.Int))
	return _f(x1, y1)
}
func (_w Wrapper) IsOnCurve(x *big.Int, y *big.Int) bool {
	_f := interp.Method("IsOnCurve", _w.Wrap).(func(x *big.Int, y *big.Int) bool)
	return _f(x, y)
}
func (_w Wrapper) Params() *elliptic.CurveParams {
	_f := interp.Method("Params", _w.Wrap).(func() *elliptic.CurveParams)
	return _f()
}
func (_w Wrapper) ScalarBaseMult(k []byte) (x *big.Int, y *big.Int) {
	_f := interp.Method("ScalarBaseMult", _w.Wrap).(func(k []byte) (x *big.Int, y *big.Int))
	return _f(k)
}
func (_w Wrapper) ScalarMult(x1 *big.Int, y1 *big.Int, k []byte) (x *big.Int, y *big.Int) {
	_f := interp.Method("ScalarMult", _w.Wrap).(func(x1 *big.Int, y1 *big.Int, k []byte) (x *big.Int, y *big.Int))
	return _f(x1, y1, k)
}
