// Code generated by 'goexports reflect'. DO NOT EDIT.

// +build go1.14,!go1.15

package stdlib

import (
	"reflect"

	"github.com/containous/yaegi/interp"
)

func init() {
	Symbols["reflect"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"Append":          reflect.ValueOf(reflect.Append),
		"AppendSlice":     reflect.ValueOf(reflect.AppendSlice),
		"Array":           reflect.ValueOf(reflect.Array),
		"ArrayOf":         reflect.ValueOf(reflect.ArrayOf),
		"Bool":            reflect.ValueOf(reflect.Bool),
		"BothDir":         reflect.ValueOf(reflect.BothDir),
		"Chan":            reflect.ValueOf(reflect.Chan),
		"ChanOf":          reflect.ValueOf(reflect.ChanOf),
		"Complex128":      reflect.ValueOf(reflect.Complex128),
		"Complex64":       reflect.ValueOf(reflect.Complex64),
		"Copy":            reflect.ValueOf(reflect.Copy),
		"DeepEqual":       reflect.ValueOf(reflect.DeepEqual),
		"Float32":         reflect.ValueOf(reflect.Float32),
		"Float64":         reflect.ValueOf(reflect.Float64),
		"Func":            reflect.ValueOf(reflect.Func),
		"FuncOf":          reflect.ValueOf(reflect.FuncOf),
		"Indirect":        reflect.ValueOf(reflect.Indirect),
		"Int":             reflect.ValueOf(reflect.Int),
		"Int16":           reflect.ValueOf(reflect.Int16),
		"Int32":           reflect.ValueOf(reflect.Int32),
		"Int64":           reflect.ValueOf(reflect.Int64),
		"Int8":            reflect.ValueOf(reflect.Int8),
		"Interface":       reflect.ValueOf(reflect.Interface),
		"Invalid":         reflect.ValueOf(reflect.Invalid),
		"MakeChan":        reflect.ValueOf(reflect.MakeChan),
		"MakeFunc":        reflect.ValueOf(reflect.MakeFunc),
		"MakeMap":         reflect.ValueOf(reflect.MakeMap),
		"MakeMapWithSize": reflect.ValueOf(reflect.MakeMapWithSize),
		"MakeSlice":       reflect.ValueOf(reflect.MakeSlice),
		"Map":             reflect.ValueOf(reflect.Map),
		"MapOf":           reflect.ValueOf(reflect.MapOf),
		"New":             reflect.ValueOf(reflect.New),
		"NewAt":           reflect.ValueOf(reflect.NewAt),
		"Ptr":             reflect.ValueOf(reflect.Ptr),
		"PtrTo":           reflect.ValueOf(reflect.PtrTo),
		"RecvDir":         reflect.ValueOf(reflect.RecvDir),
		"Select":          reflect.ValueOf(reflect.Select),
		"SelectDefault":   reflect.ValueOf(reflect.SelectDefault),
		"SelectRecv":      reflect.ValueOf(reflect.SelectRecv),
		"SelectSend":      reflect.ValueOf(reflect.SelectSend),
		"SendDir":         reflect.ValueOf(reflect.SendDir),
		"Slice":           reflect.ValueOf(reflect.Slice),
		"SliceOf":         reflect.ValueOf(reflect.SliceOf),
		"String":          reflect.ValueOf(reflect.String),
		"Struct":          reflect.ValueOf(reflect.Struct),
		"StructOf":        reflect.ValueOf(reflect.StructOf),
		"Swapper":         reflect.ValueOf(reflect.Swapper),
		"TypeOf":          reflect.ValueOf(reflect.TypeOf),
		"Uint":            reflect.ValueOf(reflect.Uint),
		"Uint16":          reflect.ValueOf(reflect.Uint16),
		"Uint32":          reflect.ValueOf(reflect.Uint32),
		"Uint64":          reflect.ValueOf(reflect.Uint64),
		"Uint8":           reflect.ValueOf(reflect.Uint8),
		"Uintptr":         reflect.ValueOf(reflect.Uintptr),
		"UnsafePointer":   reflect.ValueOf(reflect.UnsafePointer),
		"ValueOf":         reflect.ValueOf(reflect.ValueOf),
		"Zero":            reflect.ValueOf(reflect.Zero),

		// type definitions
		"ChanDir":      reflect.ValueOf((*reflect.ChanDir)(nil)),
		"Kind":         reflect.ValueOf((*reflect.Kind)(nil)),
		"MapIter":      reflect.ValueOf((*reflect.MapIter)(nil)),
		"Method":       reflect.ValueOf((*reflect.Method)(nil)),
		"SelectCase":   reflect.ValueOf((*reflect.SelectCase)(nil)),
		"SelectDir":    reflect.ValueOf((*reflect.SelectDir)(nil)),
		"SliceHeader":  reflect.ValueOf((*reflect.SliceHeader)(nil)),
		"StringHeader": reflect.ValueOf((*reflect.StringHeader)(nil)),
		"StructField":  reflect.ValueOf((*reflect.StructField)(nil)),
		"StructTag":    reflect.ValueOf((*reflect.StructTag)(nil)),
		"Type":         reflect.ValueOf((*reflect.Type)(nil)),
		"Value":        reflect.ValueOf((*reflect.Value)(nil)),
		"ValueError":   reflect.ValueOf((*reflect.ValueError)(nil)),
	}
}
func (_w Wrapper) Align() int {
	_f := interp.Method("Align", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) AssignableTo(u reflect.Type) bool {
	_f := interp.Method("AssignableTo", _w.Wrap).(func(u reflect.Type) bool)
	return _f(u)
}
func (_w Wrapper) Bits() int {
	_f := interp.Method("Bits", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) ChanDir() reflect.ChanDir {
	_f := interp.Method("ChanDir", _w.Wrap).(func() reflect.ChanDir)
	return _f()
}
func (_w Wrapper) Comparable() bool {
	_f := interp.Method("Comparable", _w.Wrap).(func() bool)
	return _f()
}
func (_w Wrapper) ConvertibleTo(u reflect.Type) bool {
	_f := interp.Method("ConvertibleTo", _w.Wrap).(func(u reflect.Type) bool)
	return _f(u)
}
func (_w Wrapper) Elem() reflect.Type {
	_f := interp.Method("Elem", _w.Wrap).(func() reflect.Type)
	return _f()
}
func (_w Wrapper) Field(i int) reflect.StructField {
	_f := interp.Method("Field", _w.Wrap).(func(i int) reflect.StructField)
	return _f(i)
}
func (_w Wrapper) FieldAlign() int {
	_f := interp.Method("FieldAlign", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) FieldByIndex(index []int) reflect.StructField {
	_f := interp.Method("FieldByIndex", _w.Wrap).(func(index []int) reflect.StructField)
	return _f(index)
}
func (_w Wrapper) FieldByName(name string) (reflect.StructField, bool) {
	_f := interp.Method("FieldByName", _w.Wrap).(func(name string) (reflect.StructField, bool))
	return _f(name)
}
func (_w Wrapper) FieldByNameFunc(match func(string) bool) (reflect.StructField, bool) {
	_f := interp.Method("FieldByNameFunc", _w.Wrap).(func(match func(string) bool) (reflect.StructField, bool))
	return _f(match)
}
func (_w Wrapper) Implements(u reflect.Type) bool {
	_f := interp.Method("Implements", _w.Wrap).(func(u reflect.Type) bool)
	return _f(u)
}
func (_w Wrapper) In(i int) reflect.Type {
	_f := interp.Method("In", _w.Wrap).(func(i int) reflect.Type)
	return _f(i)
}
func (_w Wrapper) IsVariadic() bool {
	_f := interp.Method("IsVariadic", _w.Wrap).(func() bool)
	return _f()
}
func (_w Wrapper) Key() reflect.Type {
	_f := interp.Method("Key", _w.Wrap).(func() reflect.Type)
	return _f()
}
func (_w Wrapper) Method(a0 int) reflect.Method {
	_f := interp.Method("Method", _w.Wrap).(func(a0 int) reflect.Method)
	return _f(a0)
}
func (_w Wrapper) MethodByName(a0 string) (reflect.Method, bool) {
	_f := interp.Method("MethodByName", _w.Wrap).(func(a0 string) (reflect.Method, bool))
	return _f(a0)
}
func (_w Wrapper) NumField() int {
	_f := interp.Method("NumField", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) NumIn() int {
	_f := interp.Method("NumIn", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) NumMethod() int {
	_f := interp.Method("NumMethod", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) NumOut() int {
	_f := interp.Method("NumOut", _w.Wrap).(func() int)
	return _f()
}
func (_w Wrapper) Out(i int) reflect.Type {
	_f := interp.Method("Out", _w.Wrap).(func(i int) reflect.Type)
	return _f(i)
}
func (_w Wrapper) PkgPath() string {
	_f := interp.Method("PkgPath", _w.Wrap).(func() string)
	return _f()
}
